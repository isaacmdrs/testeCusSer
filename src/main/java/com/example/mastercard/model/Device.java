/*
 * Mastercard Digital Enablement Service Customer Service API
 * The MDES Customer Service API provides our Issuer partners with resources to help resolve consumer queries about payment accounts enabled through our digitization platform.
 *
 * The version of the OpenAPI document: 2.1.7
 * Contact: apisupport@mastercard.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.example.mastercard.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.example.mastercard.JSON;

/**
 * Device
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-07-29T17:08:41.015538669-03:00[America/Sao_Paulo]")
public class Device {
  public static final String SERIALIZED_NAME_DEVICE_ID = "DeviceId";
  @SerializedName(SERIALIZED_NAME_DEVICE_ID)
  private String deviceId;

  public static final String SERIALIZED_NAME_DEVICE_NAME = "DeviceName";
  @SerializedName(SERIALIZED_NAME_DEVICE_NAME)
  private String deviceName;

  public static final String SERIALIZED_NAME_DEVICE_TYPE = "DeviceType";
  @SerializedName(SERIALIZED_NAME_DEVICE_TYPE)
  private String deviceType;

  public static final String SERIALIZED_NAME_SECURE_ELEMENT_ID = "SecureElementId";
  @SerializedName(SERIALIZED_NAME_SECURE_ELEMENT_ID)
  private String secureElementId;

  public Device() {
  }

  public Device deviceId(String deviceId) {
    this.deviceId = deviceId;
    return this;
  }

   /**
   * Serial number of the device provisioned with the token. May be masked. Conditional field, not present for CoF tokens, and only present when provided by a Wallet Provider. May be masked (by the Wallet Provider). Example (unmasked) \&quot;C2ZBY14310005664\&quot;. Example (masked) \&quot;xxxxY1431xxxxxxx\&quot;.
   * @return deviceId
  **/
  @javax.annotation.Nullable
  public String getDeviceId() {
    return deviceId;
  }

  public void setDeviceId(String deviceId) {
    this.deviceId = deviceId;
  }


  public Device deviceName(String deviceName) {
    this.deviceName = deviceName;
    return this;
  }

   /**
   * Nickname of the device provisioned with the token. Conditional field, not present for CoF tokens, and only present when the Payment App Provider has implemented the &#39;Get Device Info&#39; MDES API.
   * @return deviceName
  **/
  @javax.annotation.Nullable
  public String getDeviceName() {
    return deviceName;
  }

  public void setDeviceName(String deviceName) {
    this.deviceName = deviceName;
  }


  public Device deviceType(String deviceType) {
    this.deviceType = deviceType;
    return this;
  }

   /**
   * Type of the device provisioned with the token. Valid values: NOTE - Some values from 00-19 may indicate not only the physical form factor but also other attributes such as device technology and payment app specifications.   * &#39;00&#39; - Card.   * &#39;01&#39; - Mobile Network Operator (MNO) controlled removable secure element (SIM or UICC) personalized for use with a mobile phone or smartphone.   * &#39;02&#39; - Key Fob.   * &#39;03&#39; - Watch using a contactless chip or a fixed (non-removable) secure element not controlled by the MNO.   * &#39;04&#39; - Mobile Tag.   * &#39;05&#39; - Wristband.   * &#39;06&#39; - Mobile Phone Case or Sleeve.   * &#39;07&#39; - Mobile phone or smartphone with a fixed (non-removable) secure element controlled by the MNO, for example, code division multiple access (CDMA).   * &#39;08&#39; - Removable secure element not controlled by the MNO, for example, memory card personalized for used with a mobile phone or smartphone.   * &#39;09&#39; - Mobile Phone or smartphone with a fixed (non-removable) secure element not controlled by the MNO.   * &#39;10&#39; - MNO controlled removable secure element (SIM or UICC) personalized for use with a tablet or e-book.   * &#39;11&#39; - Tablet or e-book with a fixed (non-removable) secure element controlled by the MNO.   * &#39;12&#39; - Removable secure element not controlled by the MNO, for example, memory card personalized for use with a tablet or e-book.   * &#39;13&#39; - Tablet or e-book with fixed (non-removable) secure element not controlled by the MNO.   * &#39;14&#39; - Mobile phone or smartphone with a payment application running in a host processor.   * &#39;15&#39; - Tablet or e-book with a payment application running in a host processor.   * &#39;16&#39; - Mobile phone or smartphone with a payment application running in the Trusted Execution Environment (TEE) of a host processor.   * &#39;17&#39; - Tablet or e-book with a payment application running in the TEE of a host processor.   * &#39;18&#39; - Watch with a payment application running in the TEE of a host processor.   * &#39;19&#39; - Watch with a payment application running in a host processor. NOTE - Values from 20-99 exclusively indicate the form factor only without also indicating the storage technology.   * &#39;20&#39; - Card.   * &#39;21&#39; - Phone Mobile phone.   * &#39;22&#39; - Tablet/e-reader Tablet computer or e-reader.   * &#39;23&#39; - Watch/Wristband Watch or wristband, including a fitness band, smart strap, disposable band, watch add-on, and security/ID band.   * &#39;24&#39; - Sticker.   * &#39;25&#39; - PC PC or laptop.   * &#39;26&#39; - Device Peripheral Mobile phone case or sleeve.   * &#39;27&#39; - Tag Key fob or mobile tag.   * &#39;28&#39; - Jewelry Ring, bracelet, necklace, and cuff links.   * &#39;29&#39; - Fashion Accessory Handbag, bag charm, and glasses.   * &#39;30&#39; - Garment Dress.   * &#39;31&#39; - Domestic Appliance Refrigerator, washing machine.   * &#39;32&#39; - Vehicle Vehicle, including vehicle attached devices.   * &#39;33&#39; - Media/Gaming Device Media or gaming device, including a set top box, media player, and television.   * &#39;34&#39; to &#39;99&#39; - Reserved for future form factors. Any value in this range may occur within form factor and transaction data without prior notice. Conditional field, not present for CoF tokens, and only present when supplied by the Payment App Provider. 
   * @return deviceType
  **/
  @javax.annotation.Nullable
  public String getDeviceType() {
    return deviceType;
  }

  public void setDeviceType(String deviceType) {
    this.deviceType = deviceType;
  }


  public Device secureElementId(String secureElementId) {
    this.secureElementId = secureElementId;
    return this;
  }

   /**
   * Identifier of the secure element provisioned with the token. Conditional field, not present for CoF tokens, and only present when the token is provisioned to a secure element.
   * @return secureElementId
  **/
  @javax.annotation.Nullable
  public String getSecureElementId() {
    return secureElementId;
  }

  public void setSecureElementId(String secureElementId) {
    this.secureElementId = secureElementId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Device device = (Device) o;
    return Objects.equals(this.deviceId, device.deviceId) &&
        Objects.equals(this.deviceName, device.deviceName) &&
        Objects.equals(this.deviceType, device.deviceType) &&
        Objects.equals(this.secureElementId, device.secureElementId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(deviceId, deviceName, deviceType, secureElementId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Device {\n");
    sb.append("    deviceId: ").append(toIndentedString(deviceId)).append("\n");
    sb.append("    deviceName: ").append(toIndentedString(deviceName)).append("\n");
    sb.append("    deviceType: ").append(toIndentedString(deviceType)).append("\n");
    sb.append("    secureElementId: ").append(toIndentedString(secureElementId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("DeviceId");
    openapiFields.add("DeviceName");
    openapiFields.add("DeviceType");
    openapiFields.add("SecureElementId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to Device
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Device.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Device is not found in the empty JSON string", Device.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Device.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Device` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("DeviceId") != null && !jsonObj.get("DeviceId").isJsonNull()) && !jsonObj.get("DeviceId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `DeviceId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("DeviceId").toString()));
      }
      if ((jsonObj.get("DeviceName") != null && !jsonObj.get("DeviceName").isJsonNull()) && !jsonObj.get("DeviceName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `DeviceName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("DeviceName").toString()));
      }
      if ((jsonObj.get("DeviceType") != null && !jsonObj.get("DeviceType").isJsonNull()) && !jsonObj.get("DeviceType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `DeviceType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("DeviceType").toString()));
      }
      if ((jsonObj.get("SecureElementId") != null && !jsonObj.get("SecureElementId").isJsonNull()) && !jsonObj.get("SecureElementId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `SecureElementId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("SecureElementId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Device.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Device' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Device> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Device.class));

       return (TypeAdapter<T>) new TypeAdapter<Device>() {
           @Override
           public void write(JsonWriter out, Device value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Device read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of Device given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of Device
  * @throws IOException if the JSON string is invalid with respect to Device
  */
  public static Device fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Device.class);
  }

 /**
  * Convert an instance of Device to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

