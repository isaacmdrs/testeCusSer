/*
 * Mastercard Digital Enablement Service Customer Service API
 * The MDES Customer Service API provides our Issuer partners with resources to help resolve consumer queries about payment accounts enabled through our digitization platform.
 *
 * The version of the OpenAPI document: 2.1.7
 * Contact: apisupport@mastercard.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.example.mastercard.model;

import java.util.Objects;
import com.example.mastercard.model.Device;
import com.example.mastercard.model.Suspenders;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.example.mastercard.JSON;

/**
 * Token
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-07-29T17:08:41.015538669-03:00[America/Sao_Paulo]")
public class Token {
  public static final String SERIALIZED_NAME_TOKEN_UNIQUE_REFERENCE = "TokenUniqueReference";
  @SerializedName(SERIALIZED_NAME_TOKEN_UNIQUE_REFERENCE)
  private String tokenUniqueReference;

  public static final String SERIALIZED_NAME_PRIMARY_ACCOUNT_NUMBER_UNIQUE_REFERENCE = "PrimaryAccountNumberUniqueReference";
  @SerializedName(SERIALIZED_NAME_PRIMARY_ACCOUNT_NUMBER_UNIQUE_REFERENCE)
  private String primaryAccountNumberUniqueReference;

  public static final String SERIALIZED_NAME_ACCOUNT_PAN_SEQUENCE_NUMBER = "AccountPanSequenceNumber";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_PAN_SEQUENCE_NUMBER)
  private String accountPanSequenceNumber;

  public static final String SERIALIZED_NAME_TOKEN_SUFFIX = "TokenSuffix";
  @SerializedName(SERIALIZED_NAME_TOKEN_SUFFIX)
  private String tokenSuffix;

  public static final String SERIALIZED_NAME_EXPIRATION_DATE = "ExpirationDate";
  @SerializedName(SERIALIZED_NAME_EXPIRATION_DATE)
  private String expirationDate;

  public static final String SERIALIZED_NAME_DIGITIZATION_REQUEST_DATE_TIME = "DigitizationRequestDateTime";
  @SerializedName(SERIALIZED_NAME_DIGITIZATION_REQUEST_DATE_TIME)
  private String digitizationRequestDateTime;

  public static final String SERIALIZED_NAME_ACTIVATION_CODE_EXPIRATION_DATE_TIME = "ActivationCodeExpirationDateTime";
  @SerializedName(SERIALIZED_NAME_ACTIVATION_CODE_EXPIRATION_DATE_TIME)
  private String activationCodeExpirationDateTime;

  public static final String SERIALIZED_NAME_AUXILIARY = "Auxiliary";
  @SerializedName(SERIALIZED_NAME_AUXILIARY)
  private String auxiliary;

  public static final String SERIALIZED_NAME_CORRELATION_ID = "CorrelationId";
  @SerializedName(SERIALIZED_NAME_CORRELATION_ID)
  private String correlationId;

  public static final String SERIALIZED_NAME_CURRENT_STATUS_CODE = "CurrentStatusCode";
  @SerializedName(SERIALIZED_NAME_CURRENT_STATUS_CODE)
  private String currentStatusCode;

  public static final String SERIALIZED_NAME_CURRENT_STATUS_DESCRIPTION = "CurrentStatusDescription";
  @SerializedName(SERIALIZED_NAME_CURRENT_STATUS_DESCRIPTION)
  private String currentStatusDescription;

  public static final String SERIALIZED_NAME_CURRENT_STATUS_DATE_TIME = "CurrentStatusDateTime";
  @SerializedName(SERIALIZED_NAME_CURRENT_STATUS_DATE_TIME)
  private String currentStatusDateTime;

  public static final String SERIALIZED_NAME_FINAL_TOKENIZATION_DECISION = "FinalTokenizationDecision";
  @SerializedName(SERIALIZED_NAME_FINAL_TOKENIZATION_DECISION)
  private String finalTokenizationDecision;

  public static final String SERIALIZED_NAME_LAST_COMMENT_ID = "LastCommentId";
  @SerializedName(SERIALIZED_NAME_LAST_COMMENT_ID)
  private String lastCommentId;

  public static final String SERIALIZED_NAME_PAYMENT_APP_INSTANCE_ID = "PaymentAppInstanceId";
  @SerializedName(SERIALIZED_NAME_PAYMENT_APP_INSTANCE_ID)
  private String paymentAppInstanceId;

  public static final String SERIALIZED_NAME_PROVISIONING_STATUS_CODE = "ProvisioningStatusCode";
  @SerializedName(SERIALIZED_NAME_PROVISIONING_STATUS_CODE)
  private String provisioningStatusCode;

  public static final String SERIALIZED_NAME_PROVISIONING_STATUS_DESCRIPTION = "ProvisioningStatusDescription";
  @SerializedName(SERIALIZED_NAME_PROVISIONING_STATUS_DESCRIPTION)
  private String provisioningStatusDescription;

  public static final String SERIALIZED_NAME_STORAGE_TECHNOLOGY = "StorageTechnology";
  @SerializedName(SERIALIZED_NAME_STORAGE_TECHNOLOGY)
  private String storageTechnology;

  public static final String SERIALIZED_NAME_SOURCE = "Source";
  @SerializedName(SERIALIZED_NAME_SOURCE)
  private String source;

  public static final String SERIALIZED_NAME_TRANSACTION_CREDENTIAL_GENERATION_STATUS = "TransactionCredentialGenerationStatus";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_CREDENTIAL_GENERATION_STATUS)
  private String transactionCredentialGenerationStatus;

  public static final String SERIALIZED_NAME_SUSPENDERS = "Suspenders";
  @SerializedName(SERIALIZED_NAME_SUSPENDERS)
  private Suspenders suspenders;

  public static final String SERIALIZED_NAME_TOKEN_ACTIVATED_DATE_TIME = "TokenActivatedDateTime";
  @SerializedName(SERIALIZED_NAME_TOKEN_ACTIVATED_DATE_TIME)
  private String tokenActivatedDateTime;

  public static final String SERIALIZED_NAME_TOKEN_ASSURANCE_LEVEL = "TokenAssuranceLevel";
  @SerializedName(SERIALIZED_NAME_TOKEN_ASSURANCE_LEVEL)
  private String tokenAssuranceLevel;

  public static final String SERIALIZED_NAME_TOKEN_REQUESTOR_ID = "TokenRequestorId";
  @SerializedName(SERIALIZED_NAME_TOKEN_REQUESTOR_ID)
  private String tokenRequestorId;

  public static final String SERIALIZED_NAME_TOKEN_REQUESTOR_NAME = "TokenRequestorName";
  @SerializedName(SERIALIZED_NAME_TOKEN_REQUESTOR_NAME)
  private String tokenRequestorName;

  public static final String SERIALIZED_NAME_TOKEN_TYPE = "TokenType";
  @SerializedName(SERIALIZED_NAME_TOKEN_TYPE)
  private String tokenType;

  public static final String SERIALIZED_NAME_WALLET_ID = "WalletId";
  @SerializedName(SERIALIZED_NAME_WALLET_ID)
  private String walletId;

  public static final String SERIALIZED_NAME_DEVICE = "Device";
  @SerializedName(SERIALIZED_NAME_DEVICE)
  private Device device;

  public static final String SERIALIZED_NAME_TOKEN_DELETED_FROM_CONSUMER_APP = "TokenDeletedFromConsumerApp";
  @SerializedName(SERIALIZED_NAME_TOKEN_DELETED_FROM_CONSUMER_APP)
  private String tokenDeletedFromConsumerApp;

  public static final String SERIALIZED_NAME_TOKEN_REQUESTOR_CONSUMER_FACING_ENTITY_NAME = "TokenRequestorConsumerFacingEntityName";
  @SerializedName(SERIALIZED_NAME_TOKEN_REQUESTOR_CONSUMER_FACING_ENTITY_NAME)
  private String tokenRequestorConsumerFacingEntityName;

  public static final String SERIALIZED_NAME_VIRTUAL_CARD_NUMBER_PAN_SUFFIX = "VirtualCardNumberPanSuffix";
  @SerializedName(SERIALIZED_NAME_VIRTUAL_CARD_NUMBER_PAN_SUFFIX)
  private String virtualCardNumberPanSuffix;

  public static final String SERIALIZED_NAME_VIRTUAL_CARD_NUMBER_EXPIRATION_DATE = "VirtualCardNumberExpirationDate";
  @SerializedName(SERIALIZED_NAME_VIRTUAL_CARD_NUMBER_EXPIRATION_DATE)
  private String virtualCardNumberExpirationDate;

  public static final String SERIALIZED_NAME_VIRTUAL_CARD_NUMBER_IDENTIFIER = "VirtualCardNumberIdentifier";
  @SerializedName(SERIALIZED_NAME_VIRTUAL_CARD_NUMBER_IDENTIFIER)
  private String virtualCardNumberIdentifier;

  public Token() {
  }

  public Token tokenUniqueReference(String tokenUniqueReference) {
    this.tokenUniqueReference = tokenUniqueReference;
    return this;
  }

   /**
   * Unique reference to the token. Conditional field, present when successfully assigned. 48 character string.
   * @return tokenUniqueReference
  **/
  @javax.annotation.Nullable
  public String getTokenUniqueReference() {
    return tokenUniqueReference;
  }

  public void setTokenUniqueReference(String tokenUniqueReference) {
    this.tokenUniqueReference = tokenUniqueReference;
  }


  public Token primaryAccountNumberUniqueReference(String primaryAccountNumberUniqueReference) {
    this.primaryAccountNumberUniqueReference = primaryAccountNumberUniqueReference;
    return this;
  }

   /**
   * Unique reference to the Account PAN originally digitized. Conditional field, present when successfully assigned.
   * @return primaryAccountNumberUniqueReference
  **/
  @javax.annotation.Nullable
  public String getPrimaryAccountNumberUniqueReference() {
    return primaryAccountNumberUniqueReference;
  }

  public void setPrimaryAccountNumberUniqueReference(String primaryAccountNumberUniqueReference) {
    this.primaryAccountNumberUniqueReference = primaryAccountNumberUniqueReference;
  }


  public Token accountPanSequenceNumber(String accountPanSequenceNumber) {
    this.accountPanSequenceNumber = accountPanSequenceNumber;
    return this;
  }

   /**
   * The Account PAN Sequence Number associated with a specific token, as provided to MDES previously by the issuer. It may be used to distinguish between multiple cardholders for a single Account PAN, to represent an issuance number of a specific card, or to distinguish between different card products, such as debit or credit, that share the same Account PAN. Conditional field, present when successfully assigned. 2 characters in length, max. Supported values - 000 to 099.
   * @return accountPanSequenceNumber
  **/
  @javax.annotation.Nullable
  public String getAccountPanSequenceNumber() {
    return accountPanSequenceNumber;
  }

  public void setAccountPanSequenceNumber(String accountPanSequenceNumber) {
    this.accountPanSequenceNumber = accountPanSequenceNumber;
  }


  public Token tokenSuffix(String tokenSuffix) {
    this.tokenSuffix = tokenSuffix;
    return this;
  }

   /**
   * Last 4 digits of token in a 4 character string. Conditional field, present once the token has been designated for the digitization.
   * @return tokenSuffix
  **/
  @javax.annotation.Nullable
  public String getTokenSuffix() {
    return tokenSuffix;
  }

  public void setTokenSuffix(String tokenSuffix) {
    this.tokenSuffix = tokenSuffix;
  }


  public Token expirationDate(String expirationDate) {
    this.expirationDate = expirationDate;
    return this;
  }

   /**
   * Expiration date of token. Conditional field, present once the token has been designated for the digitization. Four digit string. Format \&quot;mmyy\&quot;.
   * @return expirationDate
  **/
  @javax.annotation.Nullable
  public String getExpirationDate() {
    return expirationDate;
  }

  public void setExpirationDate(String expirationDate) {
    this.expirationDate = expirationDate;
  }


  public Token digitizationRequestDateTime(String digitizationRequestDateTime) {
    this.digitizationRequestDateTime = digitizationRequestDateTime;
    return this;
  }

   /**
   * Date and time of the initial request for digitization of the Account PAN for this token. Conditional field, not present for CoF tokens. string, in ISO 8601 format - YYYY-MM-DDThh:mm:ssTZD .
   * @return digitizationRequestDateTime
  **/
  @javax.annotation.Nullable
  public String getDigitizationRequestDateTime() {
    return digitizationRequestDateTime;
  }

  public void setDigitizationRequestDateTime(String digitizationRequestDateTime) {
    this.digitizationRequestDateTime = digitizationRequestDateTime;
  }


  public Token activationCodeExpirationDateTime(String activationCodeExpirationDateTime) {
    this.activationCodeExpirationDateTime = activationCodeExpirationDateTime;
    return this;
  }

   /**
   * Date and time when an Activation Code will expire. Conditional field, not present for CoF tokens, and only present when an Activation Code has been generated and activation has not yet occurred. The date and time may be in the future or past. string in ISO 8601 format - YYYY-MM-DDThh:mm:ssTZD .
   * @return activationCodeExpirationDateTime
  **/
  @javax.annotation.Nullable
  public String getActivationCodeExpirationDateTime() {
    return activationCodeExpirationDateTime;
  }

  public void setActivationCodeExpirationDateTime(String activationCodeExpirationDateTime) {
    this.activationCodeExpirationDateTime = activationCodeExpirationDateTime;
  }


  public Token auxiliary(String auxiliary) {
    this.auxiliary = auxiliary;
    return this;
  }

   /**
   * Indicator set to true if the token is an auxiliary token.  Supported values - true, false. Conditional field, present only if this is an auxiliary token.
   * @return auxiliary
  **/
  @javax.annotation.Nullable
  public String getAuxiliary() {
    return auxiliary;
  }

  public void setAuxiliary(String auxiliary) {
    this.auxiliary = auxiliary;
  }


  public Token correlationId(String correlationId) {
    this.correlationId = correlationId;
    return this;
  }

   /**
   * Value linking pre-digitization messages generated during provisioning. Conditional field, not present for CoF tokens. 14 char string.
   * @return correlationId
  **/
  @javax.annotation.Nullable
  public String getCorrelationId() {
    return correlationId;
  }

  public void setCorrelationId(String correlationId) {
    this.correlationId = correlationId;
  }


  public Token currentStatusCode(String currentStatusCode) {
    this.currentStatusCode = currentStatusCode;
    return this;
  }

   /**
   * Current status of the Token. Valid values:   * \&quot;U\&quot; - Unmapped. The token has not yet been linked to the Account PAN. The process of tokenization is In Progress.   * \&quot;A\&quot; - Active. The token is linked to the Account PAN and may initiate new transactions to be authorized.   * \&quot;S\&quot; - Suspended. The token is linked to the Account PAN but may not perform transactions at the request of one or more suspenders.   * \&quot;D\&quot; - Deleted. The token is logically deleted but is still linked to the Account PAN for the purposes of post-authorization transaction processing. 
   * @return currentStatusCode
  **/
  @javax.annotation.Nullable
  public String getCurrentStatusCode() {
    return currentStatusCode;
  }

  public void setCurrentStatusCode(String currentStatusCode) {
    this.currentStatusCode = currentStatusCode;
  }


  public Token currentStatusDescription(String currentStatusDescription) {
    this.currentStatusDescription = currentStatusDescription;
    return this;
  }

   /**
   * Description of the current status.
   * @return currentStatusDescription
  **/
  @javax.annotation.Nullable
  public String getCurrentStatusDescription() {
    return currentStatusDescription;
  }

  public void setCurrentStatusDescription(String currentStatusDescription) {
    this.currentStatusDescription = currentStatusDescription;
  }


  public Token currentStatusDateTime(String currentStatusDateTime) {
    this.currentStatusDateTime = currentStatusDateTime;
    return this;
  }

   /**
   * Date and time the status was updated.  string, ISO 8601 format - YYYY-MM-DDThh:mm:ssTZD .
   * @return currentStatusDateTime
  **/
  @javax.annotation.Nullable
  public String getCurrentStatusDateTime() {
    return currentStatusDateTime;
  }

  public void setCurrentStatusDateTime(String currentStatusDateTime) {
    this.currentStatusDateTime = currentStatusDateTime;
  }


  public Token finalTokenizationDecision(String finalTokenizationDecision) {
    this.finalTokenizationDecision = finalTokenizationDecision;
    return this;
  }

   /**
   * Final decision related to the digitization of the Account PAN for this token. One character string. Valid values:   * \&quot;D\&quot; - Digitization was declined   * \&quot;A\&quot; - Digitization wasapproved   * \&quot;R\&quot; - Digitization was approved but required authentication prior to activation. Conditional field, not present for CoF tokens.  NOTE - this information is currently subject to archival processes and will be present for only 1 year following digitization. 
   * @return finalTokenizationDecision
  **/
  @javax.annotation.Nullable
  public String getFinalTokenizationDecision() {
    return finalTokenizationDecision;
  }

  public void setFinalTokenizationDecision(String finalTokenizationDecision) {
    this.finalTokenizationDecision = finalTokenizationDecision;
  }


  public Token lastCommentId(String lastCommentId) {
    this.lastCommentId = lastCommentId;
    return this;
  }

   /**
   * Identifier of the last comment associated with the token.
   * @return lastCommentId
  **/
  @javax.annotation.Nullable
  public String getLastCommentId() {
    return lastCommentId;
  }

  public void setLastCommentId(String lastCommentId) {
    this.lastCommentId = lastCommentId;
  }


  public Token paymentAppInstanceId(String paymentAppInstanceId) {
    this.paymentAppInstanceId = paymentAppInstanceId;
    return this;
  }

   /**
   * Identifier of the Payment App instance within a device that will be provisioned with a token. NOTE - This may contain the identifier of the Secure Element or a mobile device for some programs. Optional, not present for CoF tokens, and only present when supplied by the Payment App Provider.  48 characters string.
   * @return paymentAppInstanceId
  **/
  @javax.annotation.Nullable
  public String getPaymentAppInstanceId() {
    return paymentAppInstanceId;
  }

  public void setPaymentAppInstanceId(String paymentAppInstanceId) {
    this.paymentAppInstanceId = paymentAppInstanceId;
  }


  public Token provisioningStatusCode(String provisioningStatusCode) {
    this.provisioningStatusCode = provisioningStatusCode;
    return this;
  }

   /**
   * Current provisioning status of the token. Valid values:   * \&quot;T\&quot; - Awaiting cardholder acceptance of Terms and Conditions   * \&quot;P\&quot; - Token being prepared   * \&quot;D\&quot; - Token being delivered to Wallet Provider or Device   * \&quot;A\&quot; - Awaiting Activation   * \&quot;S\&quot; - Provisioning successful   * \&quot;F\&quot; - Provisioning failed. NOTE - The order of the statuses above does not indicate any order of status transitions. Conditional field, not present for CoF tokens. 
   * @return provisioningStatusCode
  **/
  @javax.annotation.Nullable
  public String getProvisioningStatusCode() {
    return provisioningStatusCode;
  }

  public void setProvisioningStatusCode(String provisioningStatusCode) {
    this.provisioningStatusCode = provisioningStatusCode;
  }


  public Token provisioningStatusDescription(String provisioningStatusDescription) {
    this.provisioningStatusDescription = provisioningStatusDescription;
    return this;
  }

   /**
   * Description of the provisioning status. Conditional field, not present for CoF tokens.
   * @return provisioningStatusDescription
  **/
  @javax.annotation.Nullable
  public String getProvisioningStatusDescription() {
    return provisioningStatusDescription;
  }

  public void setProvisioningStatusDescription(String provisioningStatusDescription) {
    this.provisioningStatusDescription = provisioningStatusDescription;
  }


  public Token storageTechnology(String storageTechnology) {
    this.storageTechnology = storageTechnology;
    return this;
  }

   /**
   * The architecture or technology used for token storage. Valid values:   * \&quot;D\&quot; - Device memory   * \&quot;P\&quot; - Device memory protected by Trusted Platform Module (TPM)   * \&quot;H\&quot; - Server   * \&quot;E\&quot; - Trusted Execution Environment (TEE)   * \&quot;S\&quot; - Secure Element (SE)   * \&quot;V\&quot; - Virtual Execution Environment (VEE) 
   * @return storageTechnology
  **/
  @javax.annotation.Nullable
  public String getStorageTechnology() {
    return storageTechnology;
  }

  public void setStorageTechnology(String storageTechnology) {
    this.storageTechnology = storageTechnology;
  }


  public Token source(String source) {
    this.source = source;
    return this;
  }

   /**
   * The source of the account information.  Must be one of:   * \&quot;ACCOUNT_ON_FILE\&quot; - Source was an existing account on file   * \&quot;ACCOUNT _ADDED_MANUALLY\&quot; - Source was new account entered manually by the account holder   * \&quot;ACCOUNT_ADDED_VIA_APPLICATION\&quot; - Source was new account added by another application (for example, Issuer banking app).    * \&quot;EXISTING_TOKEN_CREDENTIAL\&quot; - Source was an existing token 
   * @return source
  **/
  @javax.annotation.Nullable
  public String getSource() {
    return source;
  }

  public void setSource(String source) {
    this.source = source;
  }


  public Token transactionCredentialGenerationStatus(String transactionCredentialGenerationStatus) {
    this.transactionCredentialGenerationStatus = transactionCredentialGenerationStatus;
    return this;
  }

   /**
   * The status of the token&#39;s ability to generate new cryptograms by calling Replenish.  Only applicable to certain Cloud tokens.  Conditional field, not present for non-applicable tokens.  Valid values:   * \&quot;NEW\&quot; - The first cryptogram has not been generated.   * \&quot;AUTHENTICATED\&quot; -  Cardholder authenticated, cryptograms can be generated.    * \&quot;BLOCKED\&quot; - Cryptograms cannot be generated until the cardholder is authenticated.  
   * @return transactionCredentialGenerationStatus
  **/
  @javax.annotation.Nullable
  public String getTransactionCredentialGenerationStatus() {
    return transactionCredentialGenerationStatus;
  }

  public void setTransactionCredentialGenerationStatus(String transactionCredentialGenerationStatus) {
    this.transactionCredentialGenerationStatus = transactionCredentialGenerationStatus;
  }


  public Token suspenders(Suspenders suspenders) {
    this.suspenders = suspenders;
    return this;
  }

   /**
   * Get suspenders
   * @return suspenders
  **/
  @javax.annotation.Nullable
  public Suspenders getSuspenders() {
    return suspenders;
  }

  public void setSuspenders(Suspenders suspenders) {
    this.suspenders = suspenders;
  }


  public Token tokenActivatedDateTime(String tokenActivatedDateTime) {
    this.tokenActivatedDateTime = tokenActivatedDateTime;
    return this;
  }

   /**
   * Date and time that the token was activated. Conditional field, present only once the Token has been activated. string in ISO 8601 format - YYYY-MM-DDThh:mm:ssTZD.
   * @return tokenActivatedDateTime
  **/
  @javax.annotation.Nullable
  public String getTokenActivatedDateTime() {
    return tokenActivatedDateTime;
  }

  public void setTokenActivatedDateTime(String tokenActivatedDateTime) {
    this.tokenActivatedDateTime = tokenActivatedDateTime;
  }


  public Token tokenAssuranceLevel(String tokenAssuranceLevel) {
    this.tokenAssuranceLevel = tokenAssuranceLevel;
    return this;
  }

   /**
   * Indicates the level of Identification and Verification performed to validate the Cardholder and the Cardholder&#39;s account at the time the Token was issued (or at any subsquent time post-issuance).  Only present when a token has a Token Assurance Level assigned.  Supported values are 0 (Not Authenticated) and non-zero (Authenticated).
   * @return tokenAssuranceLevel
  **/
  @javax.annotation.Nullable
  public String getTokenAssuranceLevel() {
    return tokenAssuranceLevel;
  }

  public void setTokenAssuranceLevel(String tokenAssuranceLevel) {
    this.tokenAssuranceLevel = tokenAssuranceLevel;
  }


  public Token tokenRequestorId(String tokenRequestorId) {
    this.tokenRequestorId = tokenRequestorId;
    return this;
  }

   /**
   * Per EMV Co, the entity uniquely recognized by Mastercard as the Token Requestor.
   * @return tokenRequestorId
  **/
  @javax.annotation.Nullable
  public String getTokenRequestorId() {
    return tokenRequestorId;
  }

  public void setTokenRequestorId(String tokenRequestorId) {
    this.tokenRequestorId = tokenRequestorId;
  }


  public Token tokenRequestorName(String tokenRequestorName) {
    this.tokenRequestorName = tokenRequestorName;
    return this;
  }

   /**
   * The legal name of the token requestor. There can be more than one Token Requestor Id per Token Requester Name (legal name). So it is important to use both parameters to uniquely identify a token requestor.  String, up to 100 characters.
   * @return tokenRequestorName
  **/
  @javax.annotation.Nullable
  public String getTokenRequestorName() {
    return tokenRequestorName;
  }

  public void setTokenRequestorName(String tokenRequestorName) {
    this.tokenRequestorName = tokenRequestorName;
  }


  public Token tokenType(String tokenType) {
    this.tokenType = tokenType;
    return this;
  }

   /**
   * Type of token. Valid values:   * \&quot;S\&quot; - Embedded Secure Element Token   * \&quot;C\&quot; - Mastercard Cloud-Based Payments token   * \&quot;F\&quot; - Cof token. 
   * @return tokenType
  **/
  @javax.annotation.Nullable
  public String getTokenType() {
    return tokenType;
  }

  public void setTokenType(String tokenType) {
    this.tokenType = tokenType;
  }


  public Token walletId(String walletId) {
    this.walletId = walletId;
    return this;
  }

   /**
   * Identifier of the Wallet Provider who requested the digitization or tokenization. Always populated for any token.
   * @return walletId
  **/
  @javax.annotation.Nullable
  public String getWalletId() {
    return walletId;
  }

  public void setWalletId(String walletId) {
    this.walletId = walletId;
  }


  public Token device(Device device) {
    this.device = device;
    return this;
  }

   /**
   * Get device
   * @return device
  **/
  @javax.annotation.Nullable
  public Device getDevice() {
    return device;
  }

  public void setDevice(Device device) {
    this.device = device;
  }


  public Token tokenDeletedFromConsumerApp(String tokenDeletedFromConsumerApp) {
    this.tokenDeletedFromConsumerApp = tokenDeletedFromConsumerApp;
    return this;
  }

   /**
   * Indicates if the token is deleted only from the device/token requestor or both device and the MDES platform. Valid values:   * \&quot;true\&quot; - the token will be removed only from the device/token requestor but will remain active on the MDES platform. Any historical payments (such as subscriptions) will continue to be processed but no new payments will be possible as the token will have been removed from the device/token requestor.   * \&quot;false\&quot; - the token will be deleted from both the device/token requestor and the MDES platform.
   * @return tokenDeletedFromConsumerApp
  **/
  @javax.annotation.Nullable
  public String getTokenDeletedFromConsumerApp() {
    return tokenDeletedFromConsumerApp;
  }

  public void setTokenDeletedFromConsumerApp(String tokenDeletedFromConsumerApp) {
    this.tokenDeletedFromConsumerApp = tokenDeletedFromConsumerApp;
  }


  public Token tokenRequestorConsumerFacingEntityName(String tokenRequestorConsumerFacingEntityName) {
    this.tokenRequestorConsumerFacingEntityName = tokenRequestorConsumerFacingEntityName;
    return this;
  }

   /**
   * The Token Requestor name to be displayed to the consumer (consumer-facing name). UTF-8 encoding (non-English characters supported). To receive this value, contact your Mastercard representative and open a project with CIS
   * @return tokenRequestorConsumerFacingEntityName
  **/
  @javax.annotation.Nullable
  public String getTokenRequestorConsumerFacingEntityName() {
    return tokenRequestorConsumerFacingEntityName;
  }

  public void setTokenRequestorConsumerFacingEntityName(String tokenRequestorConsumerFacingEntityName) {
    this.tokenRequestorConsumerFacingEntityName = tokenRequestorConsumerFacingEntityName;
  }


  public Token virtualCardNumberPanSuffix(String virtualCardNumberPanSuffix) {
    this.virtualCardNumberPanSuffix = virtualCardNumberPanSuffix;
    return this;
  }

   /**
   * Last 4 digits of VCN PAN mapped (or to be mapped) to Token(s). Conditional - Present on VCN search request.
   * @return virtualCardNumberPanSuffix
  **/
  @javax.annotation.Nullable
  public String getVirtualCardNumberPanSuffix() {
    return virtualCardNumberPanSuffix;
  }

  public void setVirtualCardNumberPanSuffix(String virtualCardNumberPanSuffix) {
    this.virtualCardNumberPanSuffix = virtualCardNumberPanSuffix;
  }


  public Token virtualCardNumberExpirationDate(String virtualCardNumberExpirationDate) {
    this.virtualCardNumberExpirationDate = virtualCardNumberExpirationDate;
    return this;
  }

   /**
   * Expiration date of VCN PAN mapped (or to be mapped) to Token(s). MMYY format. Conditional - Present on VCN search request.
   * @return virtualCardNumberExpirationDate
  **/
  @javax.annotation.Nullable
  public String getVirtualCardNumberExpirationDate() {
    return virtualCardNumberExpirationDate;
  }

  public void setVirtualCardNumberExpirationDate(String virtualCardNumberExpirationDate) {
    this.virtualCardNumberExpirationDate = virtualCardNumberExpirationDate;
  }


  public Token virtualCardNumberIdentifier(String virtualCardNumberIdentifier) {
    this.virtualCardNumberIdentifier = virtualCardNumberIdentifier;
    return this;
  }

   /**
   * A unique value assigned by InControl. Conditional - Present on VCN search request.
   * @return virtualCardNumberIdentifier
  **/
  @javax.annotation.Nullable
  public String getVirtualCardNumberIdentifier() {
    return virtualCardNumberIdentifier;
  }

  public void setVirtualCardNumberIdentifier(String virtualCardNumberIdentifier) {
    this.virtualCardNumberIdentifier = virtualCardNumberIdentifier;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Token token = (Token) o;
    return Objects.equals(this.tokenUniqueReference, token.tokenUniqueReference) &&
        Objects.equals(this.primaryAccountNumberUniqueReference, token.primaryAccountNumberUniqueReference) &&
        Objects.equals(this.accountPanSequenceNumber, token.accountPanSequenceNumber) &&
        Objects.equals(this.tokenSuffix, token.tokenSuffix) &&
        Objects.equals(this.expirationDate, token.expirationDate) &&
        Objects.equals(this.digitizationRequestDateTime, token.digitizationRequestDateTime) &&
        Objects.equals(this.activationCodeExpirationDateTime, token.activationCodeExpirationDateTime) &&
        Objects.equals(this.auxiliary, token.auxiliary) &&
        Objects.equals(this.correlationId, token.correlationId) &&
        Objects.equals(this.currentStatusCode, token.currentStatusCode) &&
        Objects.equals(this.currentStatusDescription, token.currentStatusDescription) &&
        Objects.equals(this.currentStatusDateTime, token.currentStatusDateTime) &&
        Objects.equals(this.finalTokenizationDecision, token.finalTokenizationDecision) &&
        Objects.equals(this.lastCommentId, token.lastCommentId) &&
        Objects.equals(this.paymentAppInstanceId, token.paymentAppInstanceId) &&
        Objects.equals(this.provisioningStatusCode, token.provisioningStatusCode) &&
        Objects.equals(this.provisioningStatusDescription, token.provisioningStatusDescription) &&
        Objects.equals(this.storageTechnology, token.storageTechnology) &&
        Objects.equals(this.source, token.source) &&
        Objects.equals(this.transactionCredentialGenerationStatus, token.transactionCredentialGenerationStatus) &&
        Objects.equals(this.suspenders, token.suspenders) &&
        Objects.equals(this.tokenActivatedDateTime, token.tokenActivatedDateTime) &&
        Objects.equals(this.tokenAssuranceLevel, token.tokenAssuranceLevel) &&
        Objects.equals(this.tokenRequestorId, token.tokenRequestorId) &&
        Objects.equals(this.tokenRequestorName, token.tokenRequestorName) &&
        Objects.equals(this.tokenType, token.tokenType) &&
        Objects.equals(this.walletId, token.walletId) &&
        Objects.equals(this.device, token.device) &&
        Objects.equals(this.tokenDeletedFromConsumerApp, token.tokenDeletedFromConsumerApp) &&
        Objects.equals(this.tokenRequestorConsumerFacingEntityName, token.tokenRequestorConsumerFacingEntityName) &&
        Objects.equals(this.virtualCardNumberPanSuffix, token.virtualCardNumberPanSuffix) &&
        Objects.equals(this.virtualCardNumberExpirationDate, token.virtualCardNumberExpirationDate) &&
        Objects.equals(this.virtualCardNumberIdentifier, token.virtualCardNumberIdentifier);
  }

  @Override
  public int hashCode() {
    return Objects.hash(tokenUniqueReference, primaryAccountNumberUniqueReference, accountPanSequenceNumber, tokenSuffix, expirationDate, digitizationRequestDateTime, activationCodeExpirationDateTime, auxiliary, correlationId, currentStatusCode, currentStatusDescription, currentStatusDateTime, finalTokenizationDecision, lastCommentId, paymentAppInstanceId, provisioningStatusCode, provisioningStatusDescription, storageTechnology, source, transactionCredentialGenerationStatus, suspenders, tokenActivatedDateTime, tokenAssuranceLevel, tokenRequestorId, tokenRequestorName, tokenType, walletId, device, tokenDeletedFromConsumerApp, tokenRequestorConsumerFacingEntityName, virtualCardNumberPanSuffix, virtualCardNumberExpirationDate, virtualCardNumberIdentifier);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Token {\n");
    sb.append("    tokenUniqueReference: ").append(toIndentedString(tokenUniqueReference)).append("\n");
    sb.append("    primaryAccountNumberUniqueReference: ").append(toIndentedString(primaryAccountNumberUniqueReference)).append("\n");
    sb.append("    accountPanSequenceNumber: ").append(toIndentedString(accountPanSequenceNumber)).append("\n");
    sb.append("    tokenSuffix: ").append(toIndentedString(tokenSuffix)).append("\n");
    sb.append("    expirationDate: ").append(toIndentedString(expirationDate)).append("\n");
    sb.append("    digitizationRequestDateTime: ").append(toIndentedString(digitizationRequestDateTime)).append("\n");
    sb.append("    activationCodeExpirationDateTime: ").append(toIndentedString(activationCodeExpirationDateTime)).append("\n");
    sb.append("    auxiliary: ").append(toIndentedString(auxiliary)).append("\n");
    sb.append("    correlationId: ").append(toIndentedString(correlationId)).append("\n");
    sb.append("    currentStatusCode: ").append(toIndentedString(currentStatusCode)).append("\n");
    sb.append("    currentStatusDescription: ").append(toIndentedString(currentStatusDescription)).append("\n");
    sb.append("    currentStatusDateTime: ").append(toIndentedString(currentStatusDateTime)).append("\n");
    sb.append("    finalTokenizationDecision: ").append(toIndentedString(finalTokenizationDecision)).append("\n");
    sb.append("    lastCommentId: ").append(toIndentedString(lastCommentId)).append("\n");
    sb.append("    paymentAppInstanceId: ").append(toIndentedString(paymentAppInstanceId)).append("\n");
    sb.append("    provisioningStatusCode: ").append(toIndentedString(provisioningStatusCode)).append("\n");
    sb.append("    provisioningStatusDescription: ").append(toIndentedString(provisioningStatusDescription)).append("\n");
    sb.append("    storageTechnology: ").append(toIndentedString(storageTechnology)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    transactionCredentialGenerationStatus: ").append(toIndentedString(transactionCredentialGenerationStatus)).append("\n");
    sb.append("    suspenders: ").append(toIndentedString(suspenders)).append("\n");
    sb.append("    tokenActivatedDateTime: ").append(toIndentedString(tokenActivatedDateTime)).append("\n");
    sb.append("    tokenAssuranceLevel: ").append(toIndentedString(tokenAssuranceLevel)).append("\n");
    sb.append("    tokenRequestorId: ").append(toIndentedString(tokenRequestorId)).append("\n");
    sb.append("    tokenRequestorName: ").append(toIndentedString(tokenRequestorName)).append("\n");
    sb.append("    tokenType: ").append(toIndentedString(tokenType)).append("\n");
    sb.append("    walletId: ").append(toIndentedString(walletId)).append("\n");
    sb.append("    device: ").append(toIndentedString(device)).append("\n");
    sb.append("    tokenDeletedFromConsumerApp: ").append(toIndentedString(tokenDeletedFromConsumerApp)).append("\n");
    sb.append("    tokenRequestorConsumerFacingEntityName: ").append(toIndentedString(tokenRequestorConsumerFacingEntityName)).append("\n");
    sb.append("    virtualCardNumberPanSuffix: ").append(toIndentedString(virtualCardNumberPanSuffix)).append("\n");
    sb.append("    virtualCardNumberExpirationDate: ").append(toIndentedString(virtualCardNumberExpirationDate)).append("\n");
    sb.append("    virtualCardNumberIdentifier: ").append(toIndentedString(virtualCardNumberIdentifier)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("TokenUniqueReference");
    openapiFields.add("PrimaryAccountNumberUniqueReference");
    openapiFields.add("AccountPanSequenceNumber");
    openapiFields.add("TokenSuffix");
    openapiFields.add("ExpirationDate");
    openapiFields.add("DigitizationRequestDateTime");
    openapiFields.add("ActivationCodeExpirationDateTime");
    openapiFields.add("Auxiliary");
    openapiFields.add("CorrelationId");
    openapiFields.add("CurrentStatusCode");
    openapiFields.add("CurrentStatusDescription");
    openapiFields.add("CurrentStatusDateTime");
    openapiFields.add("FinalTokenizationDecision");
    openapiFields.add("LastCommentId");
    openapiFields.add("PaymentAppInstanceId");
    openapiFields.add("ProvisioningStatusCode");
    openapiFields.add("ProvisioningStatusDescription");
    openapiFields.add("StorageTechnology");
    openapiFields.add("Source");
    openapiFields.add("TransactionCredentialGenerationStatus");
    openapiFields.add("Suspenders");
    openapiFields.add("TokenActivatedDateTime");
    openapiFields.add("TokenAssuranceLevel");
    openapiFields.add("TokenRequestorId");
    openapiFields.add("TokenRequestorName");
    openapiFields.add("TokenType");
    openapiFields.add("WalletId");
    openapiFields.add("Device");
    openapiFields.add("TokenDeletedFromConsumerApp");
    openapiFields.add("TokenRequestorConsumerFacingEntityName");
    openapiFields.add("VirtualCardNumberPanSuffix");
    openapiFields.add("VirtualCardNumberExpirationDate");
    openapiFields.add("VirtualCardNumberIdentifier");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to Token
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Token.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Token is not found in the empty JSON string", Token.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Token.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Token` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("TokenUniqueReference") != null && !jsonObj.get("TokenUniqueReference").isJsonNull()) && !jsonObj.get("TokenUniqueReference").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TokenUniqueReference` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TokenUniqueReference").toString()));
      }
      if ((jsonObj.get("PrimaryAccountNumberUniqueReference") != null && !jsonObj.get("PrimaryAccountNumberUniqueReference").isJsonNull()) && !jsonObj.get("PrimaryAccountNumberUniqueReference").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `PrimaryAccountNumberUniqueReference` to be a primitive type in the JSON string but got `%s`", jsonObj.get("PrimaryAccountNumberUniqueReference").toString()));
      }
      if ((jsonObj.get("AccountPanSequenceNumber") != null && !jsonObj.get("AccountPanSequenceNumber").isJsonNull()) && !jsonObj.get("AccountPanSequenceNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `AccountPanSequenceNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("AccountPanSequenceNumber").toString()));
      }
      if ((jsonObj.get("TokenSuffix") != null && !jsonObj.get("TokenSuffix").isJsonNull()) && !jsonObj.get("TokenSuffix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TokenSuffix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TokenSuffix").toString()));
      }
      if ((jsonObj.get("ExpirationDate") != null && !jsonObj.get("ExpirationDate").isJsonNull()) && !jsonObj.get("ExpirationDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ExpirationDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ExpirationDate").toString()));
      }
      if ((jsonObj.get("DigitizationRequestDateTime") != null && !jsonObj.get("DigitizationRequestDateTime").isJsonNull()) && !jsonObj.get("DigitizationRequestDateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `DigitizationRequestDateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("DigitizationRequestDateTime").toString()));
      }
      if ((jsonObj.get("ActivationCodeExpirationDateTime") != null && !jsonObj.get("ActivationCodeExpirationDateTime").isJsonNull()) && !jsonObj.get("ActivationCodeExpirationDateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ActivationCodeExpirationDateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ActivationCodeExpirationDateTime").toString()));
      }
      if ((jsonObj.get("Auxiliary") != null && !jsonObj.get("Auxiliary").isJsonNull()) && !jsonObj.get("Auxiliary").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Auxiliary` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Auxiliary").toString()));
      }
      if ((jsonObj.get("CorrelationId") != null && !jsonObj.get("CorrelationId").isJsonNull()) && !jsonObj.get("CorrelationId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `CorrelationId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("CorrelationId").toString()));
      }
      if ((jsonObj.get("CurrentStatusCode") != null && !jsonObj.get("CurrentStatusCode").isJsonNull()) && !jsonObj.get("CurrentStatusCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `CurrentStatusCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("CurrentStatusCode").toString()));
      }
      if ((jsonObj.get("CurrentStatusDescription") != null && !jsonObj.get("CurrentStatusDescription").isJsonNull()) && !jsonObj.get("CurrentStatusDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `CurrentStatusDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("CurrentStatusDescription").toString()));
      }
      if ((jsonObj.get("CurrentStatusDateTime") != null && !jsonObj.get("CurrentStatusDateTime").isJsonNull()) && !jsonObj.get("CurrentStatusDateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `CurrentStatusDateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("CurrentStatusDateTime").toString()));
      }
      if ((jsonObj.get("FinalTokenizationDecision") != null && !jsonObj.get("FinalTokenizationDecision").isJsonNull()) && !jsonObj.get("FinalTokenizationDecision").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `FinalTokenizationDecision` to be a primitive type in the JSON string but got `%s`", jsonObj.get("FinalTokenizationDecision").toString()));
      }
      if ((jsonObj.get("LastCommentId") != null && !jsonObj.get("LastCommentId").isJsonNull()) && !jsonObj.get("LastCommentId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `LastCommentId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("LastCommentId").toString()));
      }
      if ((jsonObj.get("PaymentAppInstanceId") != null && !jsonObj.get("PaymentAppInstanceId").isJsonNull()) && !jsonObj.get("PaymentAppInstanceId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `PaymentAppInstanceId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("PaymentAppInstanceId").toString()));
      }
      if ((jsonObj.get("ProvisioningStatusCode") != null && !jsonObj.get("ProvisioningStatusCode").isJsonNull()) && !jsonObj.get("ProvisioningStatusCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ProvisioningStatusCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ProvisioningStatusCode").toString()));
      }
      if ((jsonObj.get("ProvisioningStatusDescription") != null && !jsonObj.get("ProvisioningStatusDescription").isJsonNull()) && !jsonObj.get("ProvisioningStatusDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ProvisioningStatusDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ProvisioningStatusDescription").toString()));
      }
      if ((jsonObj.get("StorageTechnology") != null && !jsonObj.get("StorageTechnology").isJsonNull()) && !jsonObj.get("StorageTechnology").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `StorageTechnology` to be a primitive type in the JSON string but got `%s`", jsonObj.get("StorageTechnology").toString()));
      }
      if ((jsonObj.get("Source") != null && !jsonObj.get("Source").isJsonNull()) && !jsonObj.get("Source").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Source` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Source").toString()));
      }
      if ((jsonObj.get("TransactionCredentialGenerationStatus") != null && !jsonObj.get("TransactionCredentialGenerationStatus").isJsonNull()) && !jsonObj.get("TransactionCredentialGenerationStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TransactionCredentialGenerationStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TransactionCredentialGenerationStatus").toString()));
      }
      // validate the optional field `Suspenders`
      if (jsonObj.get("Suspenders") != null && !jsonObj.get("Suspenders").isJsonNull()) {
        Suspenders.validateJsonElement(jsonObj.get("Suspenders"));
      }
      if ((jsonObj.get("TokenActivatedDateTime") != null && !jsonObj.get("TokenActivatedDateTime").isJsonNull()) && !jsonObj.get("TokenActivatedDateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TokenActivatedDateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TokenActivatedDateTime").toString()));
      }
      if ((jsonObj.get("TokenAssuranceLevel") != null && !jsonObj.get("TokenAssuranceLevel").isJsonNull()) && !jsonObj.get("TokenAssuranceLevel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TokenAssuranceLevel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TokenAssuranceLevel").toString()));
      }
      if ((jsonObj.get("TokenRequestorId") != null && !jsonObj.get("TokenRequestorId").isJsonNull()) && !jsonObj.get("TokenRequestorId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TokenRequestorId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TokenRequestorId").toString()));
      }
      if ((jsonObj.get("TokenRequestorName") != null && !jsonObj.get("TokenRequestorName").isJsonNull()) && !jsonObj.get("TokenRequestorName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TokenRequestorName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TokenRequestorName").toString()));
      }
      if ((jsonObj.get("TokenType") != null && !jsonObj.get("TokenType").isJsonNull()) && !jsonObj.get("TokenType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TokenType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TokenType").toString()));
      }
      if ((jsonObj.get("WalletId") != null && !jsonObj.get("WalletId").isJsonNull()) && !jsonObj.get("WalletId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `WalletId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("WalletId").toString()));
      }
      // validate the optional field `Device`
      if (jsonObj.get("Device") != null && !jsonObj.get("Device").isJsonNull()) {
        Device.validateJsonElement(jsonObj.get("Device"));
      }
      if ((jsonObj.get("TokenDeletedFromConsumerApp") != null && !jsonObj.get("TokenDeletedFromConsumerApp").isJsonNull()) && !jsonObj.get("TokenDeletedFromConsumerApp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TokenDeletedFromConsumerApp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TokenDeletedFromConsumerApp").toString()));
      }
      if ((jsonObj.get("TokenRequestorConsumerFacingEntityName") != null && !jsonObj.get("TokenRequestorConsumerFacingEntityName").isJsonNull()) && !jsonObj.get("TokenRequestorConsumerFacingEntityName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TokenRequestorConsumerFacingEntityName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TokenRequestorConsumerFacingEntityName").toString()));
      }
      if ((jsonObj.get("VirtualCardNumberPanSuffix") != null && !jsonObj.get("VirtualCardNumberPanSuffix").isJsonNull()) && !jsonObj.get("VirtualCardNumberPanSuffix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `VirtualCardNumberPanSuffix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("VirtualCardNumberPanSuffix").toString()));
      }
      if ((jsonObj.get("VirtualCardNumberExpirationDate") != null && !jsonObj.get("VirtualCardNumberExpirationDate").isJsonNull()) && !jsonObj.get("VirtualCardNumberExpirationDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `VirtualCardNumberExpirationDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("VirtualCardNumberExpirationDate").toString()));
      }
      if ((jsonObj.get("VirtualCardNumberIdentifier") != null && !jsonObj.get("VirtualCardNumberIdentifier").isJsonNull()) && !jsonObj.get("VirtualCardNumberIdentifier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `VirtualCardNumberIdentifier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("VirtualCardNumberIdentifier").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Token.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Token' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Token> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Token.class));

       return (TypeAdapter<T>) new TypeAdapter<Token>() {
           @Override
           public void write(JsonWriter out, Token value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Token read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of Token given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of Token
  * @throws IOException if the JSON string is invalid with respect to Token
  */
  public static Token fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Token.class);
  }

 /**
  * Convert an instance of Token to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

